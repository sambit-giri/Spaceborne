# TODO infer EP Ed from nz, or better delete it altogether
# TODO add general description
# TODO merge with cfg.yaml from spaceborne_covg
# TODO add dzGC
# TODO delete dz shifts?
# TODO hardcode shift_nz_interpolation_kind to spline
# TODO remove compute_bnt_with_shifted_nz_for_zcuts??

cosmology:
    Om: 0.32
    Ob: 0.05
    wz: -1.0
    wa: 0.0
    h: 0.6737
    ns: 0.966
    s8: 0.816
    logT: 7.75
    ODE: 0.68
    m_nu: 0.06
    N_eff: 3.046
    Om_k0: 0

intrinsic_alignment:
    Aia: 0.16
    eIA: 1.66
    bIA: 0.0
    CIA: 0.0134
    z_pivot_IA: 0
    lumin_ratio_filename: null  # null if not used, otherwise path to the file (e.g. ./input/scaledmeanlum-E2Sa.dat)

# extra parameters to be passed to CCL cosmo object, eg CAMB extra parameters
# (see https://ccl.readthedocs.io/en/latest/api/pyccl.cosmology.html#pyccl.cosmology.Cosmology
# for the different options)
extra_parameters:
    camb:
        halofit_version: mead2020_feedback
        kmax: 100
        HMCode_logT_AGN: 7.75
        num_massive_neutrinos: 1
        dark_energy_model: ppf

# Halo model configuration using CCL classes (https://ccl.readthedocs.io/en/latest/api/pyccl.halos.html)
# Each parameter maps directly to a CCL class, and has exactly its name
halo_model:
    mass_def: MassDef200m
    concentration: ConcentrationDuffy08
    mass_function: MassFuncTinker10
    halo_bias: HaloBiasTinker10
    halo_profile_dm: HaloProfileNFW
    halo_profile_hod: HaloProfileHOD

C_ell:
    which_gal_bias: "FS2_polynomial_fit" # options: 'from_input', 'FS2_polynomial_fit'
    which_mag_bias: "FS2_polynomial_fit" # options: 'from_input', 'FS2_polynomial_fit'
    # bias_function: analytical # 'analytical', 'leporifit', 'pocinofit'
    # bias_model: step-wise # 'step-wise', 'constant', 'linint', 'ones', 'polynomial'
    # coefficients for the polynomial galaxy and magnification bias fits to FS2
    galaxy_bias_fit_coeff: [1.33291, -0.72414, 1.0183, -0.14913]
    magnification_bias_fit_coeff: [-1.50685, 1.35034, 0.08321, 0.04279]

    # multiplicative shear bias per redshift bin
    mult_shear_bias: [0, 0, 0]

    # input files for the galaxy and magnification bias. Should have shape (nz_points, zbins + 1), and sufficient
    # redshift support. These files are only used if `which_gal_bias` or `which_mag_bias` are set to 'from_input'.
    gal_bias_table_filename: ./input/gal_bias.txt 
    mag_bias_table_filename: ./input/mag_bias.txt  # TODO test this!

    # boolean flags for redshift-space distortion, intrinsic alignment
    has_rsd: False
    has_IA: True
    has_magnification_bias: True

    # keyword arguments for CCL Cl calculation (excluding `p_of_k_a`), described in
    # https://ccl.readthedocs.io/en/latest/api/pyccl.cosmology.html#pyccl.cosmology.Cosmology.angular_cl
    cl_CCL_kwargs:
        l_limber: -1
        limber_integration_method: spline  
        non_limber_integration_method: FKEM  

nz:
    EP_or_ED: EP  # Type: str. Options: [EP, ED] Equipopulated or Equidistant redshift bins

    # Type: str. Paths to source and lens redshift distributions. These must have shape (z_points, zbins + 1)
    nz_sources_filename: ./input/nzTab-EP03-zedMin02-zedMax25-mag245.dat  # str
    nz_lenses_filename: ./input/nzTab-EP03-zedMin02-zedMax25-mag245.dat  # str

    # Type: list. Number of galaxies per arcmin**2 for each redshift bin. Should be of len(zbins)
    ngal_sources: [8.09216, 8.09215, 8.09215]
    ngal_lenses: [8.09216, 8.09215, 8.09215]

    # Type: list. Shift in the redshift distribution per redshift bin. Should be of len(zbins)
    dzWL: [-0.008848, 0.051368, 0.059484]
    dzGC: [-0.008848, 0.051368, 0.059484]

    shift_nz: True
    shift_nz_interpolation_kind: linear # TODO delete this
    normalize_shifted_nz: True # TODO delete this
    nz_gaussian_smoothing: False # TODO delete this
    nz_gaussian_smoothing_sigma: 2 # TODO delete this
    plot_nz_tocheck: True # TODO delete this

mask:
    mask_path: .../mask.fits
    nside_mask: 1024
    fsky: 0.3210678603147902
    survey_area_deg2: 13245

ell_binning:
    ell_min: 10 # minimum ell for 3x2pt
    ell_max_WL: 3000 # maximum ell for WL
    ell_max_GC: 3000 # maximum ell for GC
    ell_max_3x2pt: 3000
    # the case with the largest range is nbl_WL_opt. This is the reference ell binning from which the cuts are applied;
    # in principle, the other binning should be consistent with this one and should not be hardcoded, as long as
    # lmax=5000, 3000 holds
    nbl_WL_opt: 32 # this is the value from which the various bin cuts are applied, do not change it
    ell_max_WL_opt: 5000 # this is the value from which the various bin cuts are applied, do not change it

ell_cuts:
    apply_ell_cuts: False
    center_or_min: center # cut if the bin *center* or the bin *lower edge* is larger than ell_max[zi, zj]
    cl_ell_cuts: False
    cov_ell_cuts: False
    kmax_h_over_Mpc_ref: 1.0 # this is used when ell_cuts is False, also...?
    kmax_h_over_Mpc_list: [0.1, 0.16681005, 0.27825594, 0.46415888, 0.77426368, 1.29154967, 2.15443469, 3.59381366, 5.9948425, 10.]

BNT:
    cl_BNT_transform: False
    cov_BNT_transform: False
    compute_bnt_with_shifted_nz_for_zcuts: False # ! lets test this
    include_ia_in_bnt_kernel_for_zcuts: False

covariance:
    n_probes: 2 # Number of probes considered in the covariance

    G: True # Enable/disable the Gaussian covariance term.
    SSC: True # Enable/disable the super-sample covariance (SSC) term.
    cNG: False # Enable/disable the connected non-Gaussian (cNG) covariance term.

    G_code: Spaceborne
    # Specifies the code to compute G. Options:
    # [Spaceborne, OneCovariance]

    SSC_code: Spaceborne
    # Specifies the code to compute SSC. Options:
    # [Spaceborne, OneCovariance, PyCCL]

    cNG_code: PyCCL
    # Specifies the code to compute cNG. Options:
    # [OneCovariance, PyCCL]

    # -- Ordering-related settings --
    triu_tril: triu
    # Choose whether to use the upper ('triu') or lower ('tril') triangle
    # of the auto-Cl zbins (C_{ij}(\ell)^AA = C_{ji}(\ell)^AA).
    row_col_major: row-major
    # Within the upper or lower triangle, count indices in
    # a row-major or column-major order.
    probe_ordering: [["L", "L"], ["G", "L"], ["G", "G"]] 
    # ordering of the different 3x2pt probes in the covariance matrix
    covariance_ordering_2D: ell_probe_zpair 
    # Determines the ordering of the covariance matrix in 2D. Options:
    # - ell_probe_zpair: Ordered by multipole (ell), then probe type, then redshift pair.
    # - probe_ell_zpair: Ordered by probe type, then multipole (ell), then redshift pair. This is the ordeing used by CLOE

    split_gaussian_cov: True
    # Whether to split the Gaussian covariance term into the
    # sample variance, noise and mixed terms

    sigma_eps_i: 0.26
    # Type: float. Ellipticity dispersion *per component* = sigma_eps_i.
    # total ellipticity dispersion = sigma_eps
    # sigma_eps = (sigma_eps_i * np.sqrt(2))

    which_sigma2_b: polar_cap_on_the_fly
    # Type: str | None. Sigma2_b settings, common to Spaceborne and PyCCL. Can be one of:
    # - full_curved_sky: Use the full- (curved-) sky expression (for Spaceborne only). In this case, the output covmat
    # - from_input_mask: input a mask with path specified by mask_path
    # - polar_cap_on_the_fly: generate a polar cap during the run, with nside specified by nside
    # - null (None): use the flat-sky expression (valid for PyCCL only)
    # - flat_sky: use the flat-sky expression (valud for PyCCL only)
    #   has to be rescaled by fsky

    # TODO demove halo_model_CCL in public version! otherwise, fork needed
    which_pk_responses: halo_model # 'halo_model' or 'separate_universe'

    which_b1g_in_resp: from_HOD
    # Which first-order galaxy bias to use in the computation of the counterterms for the gm and gg responses.
    # Can be one of:
    # - 'from_HOD' (from the Halo Occupation Distribution previously initialized)
    # - 'from_input' (from the input tabulated galaxy bias values)/FS2 fit computed in SB
    # Setting this to 'from_HOD' will match perfectly 'halo_model_CCL'

    include_b2g: True
    # Whether or not to include the second-order galaxy bias in the GCph SU responses
    
    include_terasawa_terms: True
    # Whether or not to include the additional terms of Terasawa et al [arXiv:2310.13330]
    # in the halo model responses

    load_cached_sigma2_b: False # bool. Whether to load the previously computed sigma2_b.
    
    # k grid used for power spectrum and trispectrum computation
    log10_k_min: -5  # (-5, -4) (before, after)
    log10_k_max: 2  # (2, 1) (before, after)
    k_steps: 200
    
    z_min: 0.02 # SU responses' kmax allow for z_min = 0.016, at most.
    z_max: 3.
    z_steps: 300 # number of z steps used for the NG covariance projection. Should be quite high, something like 5000
    z_steps_trisp: 100  # number of z steps used to compute the trispectrum - around 100 should be enough

    use_KE_approximation: True

    cov_filename: cov_{which_ng_cov:s}_{probe:s}_{ndim}.npz

PyCCL:
    cov_integration_method: spline
    # (from CCL docs): integration method to be used for the Limber integrals.
    # Possibilities: 'qag_quad' (GSL's qag method backed up by quad when it fails)
    # and 'spline' (the integrand is splined and then integrated analytically).
    # DSnote: note that the former could give errors.

    load_cached_tkka: False # TODO restore if there is time

    n_samples_wf: 1000
    # (from CCL docs): number of points over which to compute the radial kernels (weight functions).
    # See e.g. documentation of https://ccl.readthedocs.io/en/latest/api/pyccl.tracers.html#pyccl.tracers.NumberCountsTracer

    # precision parameters for splines and numerical integration, described in
    # https://ccl.readthedocs.io/en/latest/source/notation_and_other_cosmological_conventions.html#controlling-splines-and-numerical-accuracy.
    # spline_params and gsl_params should be dict or None (null in YAML).
    spline_params:
        A_SPLINE_NA_PK: 240
        K_MAX_SPLINE: 300
    gsl_params: null

OneCovariance:
    precision_settings: default # 'high_precision' or 'default'  # TODO delete this
    path_to_oc_executable: /home/davide/Documenti/Lavoro/Programmi/OneCovariance/covariance.py
    path_to_oc_ini: ./input/config_3x2pt_pure_Cell_general.ini
    consistency_checks: False

misc:
    num_threads: 40 # how many threads to use for the Julia SSC integral with @tturbo

    # some sanity checks on the covariance matrix. These could take a while to run.
    test_numpy_inversion: True # test for errors in np.linalg.inv
    test_condition_number: True # check if condition number is above 1e10
    test_cholesky_decomposition: True # test if cholesky decomposition fails
    test_symmetry: True # test if covariance matrix is symmetric (cov = cov.T)

    output_path: ./output
    save_output_as_benchmark: True # for testing purposes
    bench_filename: ../Spaceborne_bench/output_SB_KE_respCCLHOD_newgrids_100steps # for testing purposes
    path_to_jl_integrator: ./spaceborne/julia_integrator.jl

CCL_precision:
