# TODO add general description
# TODO remove compute_bnt_with_shifted_nz_for_zcuts??
cosmology:
    Om: 0.32        # Type: float. Matter density parameter
    Ob: 0.05        # Type: float. Baryon density parameter
    wz: -1.0        # Type: float. Dark energy equation of state parameter
    wa: 0.0         # Type: float. Evolution of dark energy equation of state parameter
    h: 0.6737       # Type: float. Dimensionless Hubble parameter
    ns: 0.966       # Type: float. Scalar spectral index
    s8: 0.816       # Type: float. Amplitude of matter fluctuations
    logT: 7.75      # Type: float. AGN feedback temperature
    ODE: 0.68       # Type: float. Dark energy density parameter
    m_nu: 0.06      # Type: float. Sum of neutrino masses
    N_eff: 3.046    # Type: float. Effective number of relativistic species
    Om_k0: 0        # Type: float. Curvature density parameter

intrinsic_alignment:
    Aia: 0.16       # Type: float
    eIA: 1.66       # Type: float
    bIA: 0.0        # Type: float
    CIA: 0.0134     # Type: float
    z_pivot_IA: 0   # Type: float
    lumin_ratio_filename: null  # Type: str | None. null if not used, otherwise path to the file (e.g. ./input/scaledmeanlum-E2Sa.dat)

# extra parameters to be passed to CCL cosmo object, eg CAMB extra parameters
# (see https://ccl.readthedocs.io/en/latest/api/pyccl.cosmology.html#pyccl.cosmology.Cosmology
# for the different options)
extra_parameters:
    camb:
        halofit_version: mead2020_feedback # Type: str
        kmax: 100 # Type: float | int
        HMCode_logT_AGN: 7.75 # Type: float
        num_massive_neutrinos: 1 # Type: int
        dark_energy_model: ppf # Type: str

# Halo model configuration using CCL classes (https://ccl.readthedocs.io/en/latest/api/pyccl.halos.html)
# Each parameter maps directly to a CCL class, and has exactly its name
halo_model:
    mass_def: MassDef200m # Type: str
    concentration: ConcentrationDuffy08 # Type: str
    mass_function: MassFuncTinker10 # Type: str
    halo_bias: HaloBiasTinker10 # Type: str
    halo_profile_dm: HaloProfileNFW # Type: str
    halo_profile_hod: HaloProfileHOD # Type: str

C_ell:
    which_gal_bias: "FS2_polynomial_fit" # Type: str. Options: ['from_input', 'FS2_polynomial_fit']
    which_mag_bias: "FS2_polynomial_fit" # Type: str. Options: ['from_input', 'FS2_polynomial_fit']
    
    # coefficients for the polynomial galaxy and magnification bias fits to FS2.
    # These are ignored if `which_gal_bias` or `which_mag_bias` are set to 'from_input'.
    galaxy_bias_fit_coeff: [1.33291, -0.72414, 1.0183, -0.14913] # Type: list[float]
    magnification_bias_fit_coeff: [-1.50685, 1.35034, 0.08321, 0.04279] # Type: list[float]

    # multiplicative shear bias per redshift bin
    mult_shear_bias: [0.0, 0.0, 0.0] # Type: list[float]

    # input files for the galaxy and magnification bias. Should have shape (nz_points, zbins + 1), and sufficient
    # redshift support. These files are only used if `which_gal_bias` or `which_mag_bias` are set to 'from_input'.
    gal_bias_table_filename: ./input/gal_bias.txt # Type: str
    mag_bias_table_filedname: ./input/mag_bias.txt # Type: str

    # boolean flags for redshift-space distortion, intrinsic alignment
    has_rsd: False # Type: bool. Enable/disable redshift-space distortions.
    has_IA: True # Type: bool. Enable/disable intrinsic alignment.
    has_magnification_bias: True # Type: bool. Enable/disable magnification bias.

    # keyword arguments for CCL Cl calculation (excluding `p_of_k_a`), described in
    # https://ccl.readthedocs.io/en/latest/api/pyccl.cosmology.html#pyccl.cosmology.Cosmology.angular_cl
    cl_CCL_kwargs:
        l_limber: -1 # Type: int
        limber_integration_method: spline # Type: str
        non_limber_integration_method: FKEM # Type: str

nz:
    # Type: str. Paths to source and lens redshift distributions. These must have shape (z_points, zbins + 1)
    nz_sources_filename: ./input/nzTab-EP03-zedMin02-zedMax25-mag245.dat
    nz_lenses_filename: ./input/nzTab-EP03-zedMin02-zedMax25-mag245.dat

    # Type: list[float]. Number of galaxies per arcmin**2 for each redshift bin. Should be of len(zbins)
    ngal_sources: [8.09216, 8.09215, 8.09215]
    ngal_lenses: [8.09216, 8.09215, 8.09215]

    shift_nz: True # Type: bool. 
    # Whether or not to apply per-bin shifts to the 
    # redshift distributions.
    
    # Type: list[float]. Shift in the redshift distribution per redshift bin. Should be of len(zbins)
    dzWL: [-0.008848, 0.051368, 0.059484]
    dzGC: [-0.008848, 0.051368, 0.059484]

    normalize_shifted_nz: True # Type: bool # TODO delete this
    nz_gaussian_smoothing: False # Type: bool # TODO delete this
    nz_gaussian_smoothing_sigma: 2 # Type: int # TODO delete this
    plot_nz_tocheck: True # Type: bool # TODO delete this

mask:
    mask_path: .../mask.fits # Type: str
    nside_mask: 1024 # Type: int
    fsky: 0.3210678603147902 # Type: float
    survey_area_deg2: 13245 # Type: int

ell_binning:
    ell_min: 10 # Type: int. Minimum ell for 3x2pt
    ell_max_WL: 3000 # Type: int. Maximum ell for WL
    ell_max_GC: 3000 # Type: int. Maximum ell for GC
    ell_max_3x2pt: 3000 # Type: int
    nbl_WL_opt: 32 # Type: int. This is the value from which the various bin cuts are applied, do not change it
    ell_max_WL_opt: 5000 # Type: int. This is the value from which the various bin cuts are applied, do not change it

ell_cuts:
    apply_ell_cuts: False # Type: bool
    center_or_min: center # Type: str. Cut if the bin *center* or the bin *lower edge* is larger than ell_max[zi, zj]
    cl_ell_cuts: False # Type: bool
    cov_ell_cuts: False # Type: bool
    kmax_h_over_Mpc_ref: 1.0 # Type: float. This is used when ell_cuts is False, also...?
    kmax_h_over_Mpc_list: [0.1, 0.16681005, 0.27825594, 0.46415888, 0.77426368, 1.29154967, 2.15443469, 3.59381366, 5.9948425, 10.] # Type: list[float]

BNT:
    cl_BNT_transform: False # Type: bool
    cov_BNT_transform: False # Type: bool
    compute_bnt_with_shifted_nz_for_zcuts: False # Type: bool. Lets test this
    include_ia_in_bnt_kernel_for_zcuts: False # Type: bool

covariance:
    n_probes: 2 # Type: int. Number of probes considered in the covariance

    G: True # Type: bool. Enable/disable the Gaussian covariance term.
    SSC: True # Type: bool. Enable/disable the super-sample covariance (SSC) term
    cNG: False # Type: bool. Enable/disable the connected non-Gaussian (cNG) covariance term

    # Which code to use for the different covariance terms
    G_code: Spaceborne # Type: str. Options: [Spaceborne, OneCovariance]
    SSC_code: Spaceborne # Type: str. Options: [Spaceborne, OneCovariance, PyCCL]
    cNG_code: PyCCL # Type: str. Options: [OneCovariance, PyCCL]

    # -- Ordering-related settings --
    triu_tril: triu # Type: str. Options: ['triu', 'tril']
    # Choose whether to use the upper ('triu') or lower ('tril') triangle
    # of the auto-probe (LL, GG) zbins (C_{ij}(\ell)^AA = C_{ji}(\ell)^AA).
    row_col_major: row-major # Type: str. Options: ['row-major', 'column-major']
    # Within the upper or lower triangle, count indices in
    # a row-major or column-major order.
    probe_ordering: [["L", "L"], ["G", "L"], ["G", "G"]] # Type: list[list[str]]
    # ordering of the different 3x2pt probes in the covariance matrix
    covariance_ordering_2D: ell_probe_zpair # Type: str. 
    # Options: [ell_probe_zpair, probe_ell_zpair, probe_zpair_ell, zpair_probe_ell]
    # Determines the ordering of the covariance matrix in 2D, with the outermost 
    # loop corresponding to the leftmost index.
    # - ell_probe_zpair: Ordered by multipole (ell), then probe type, then redshift pair.
    # - probe_ell_zpair: Ordered by probe type, then multipole (ell), then redshift pair. This is the ordering used by CLOE
    save_full_cov: True # Type: bool.
    # Whether to save the full 6D (10D) covariance matrix, without to any indices compression or reshaping. 
    # In the case of the single probes, this is an array of shape
    # (ellbins, ellbins, zbins, zbins, zbins, zbins).
    # In the 3x2pt case, this is an array of shape
    # (n_probes, n_probes, n_probes, n_probes, ellbins, ellbins, zbins, zbins, zbins, zbins), 
    # with nbl the number of probes. The probe index is by default 0 for WL, 1 for GC.
    # Keep in mind that the arrays will likely be quite large. 
    
    split_gaussian_cov: True # Type: bool
    # Whether to split the Gaussian covariance term into the
    # sample variance, noise and mixed terms

    sigma_eps_i: 0.26 # Type: float
    # Ellipticity dispersion *per component* = sigma_eps_i.
    # total ellipticity dispersion = sigma_eps
    # sigma_eps = (sigma_eps_i * np.sqrt(2))

    which_sigma2_b: polar_cap_on_the_fly # Type: str | None
    # Sigma2_b settings, common to Spaceborne and PyCCL. Can be one of:
    # - full_curved_sky: Use the full- (curved-) sky expression (for Spaceborne only). In this case, the output covmat
    # - from_input_mask: input a mask with path specified by mask_path
    # - polar_cap_on_the_fly: generate a polar cap during the run, with nside specified by nside
    # - null (None): use the flat-sky expression (valid for PyCCL only)
    # - flat_sky: use the flat-sky expression (valid for PyCCL only)
    #   has to be rescaled by fsky

    which_pk_responses: halo_model # Type: str. Options: ['halo_model', 'separate_universe']

    which_b1g_in_resp: from_input # Type: str. Options: ['from_HOD', 'from_input']
    # Which first-order galaxy bias to use in the computation of the counterterms for the gm and gg responses.
    # Can be one of:
    # - 'from_HOD' (from the Halo Occupation Distribution previously initialized)
    # - 'from_input' (from the input tabulated galaxy bias values)/FS2 fit computed in SB

    include_b2g: True # Type: bool
    # Whether or not to include the second-order galaxy bias in the GCph SU responses
    
    include_terasawa_terms: False # Type: bool
    # Whether or not to include the additional terms of Terasawa et al [arXiv:2310.13330] in the halo model responses

    load_cached_sigma2_b: False # Type: bool. Whether to load the previously computed sigma2_b.
    
    # k grid used for power spectrum and trispectrum computation
    log10_k_min: -5  # Type: float 
    log10_k_max: 2  # Type: float
    k_steps: 200  # Type: int
    
    z_min: 0.02 # Type: float. SU responses' kmax allow for z_min = 0.016, at most.
    z_max: 3.0 # Type: float
    z_steps: 300 # Type: int. Number of z steps used for the NG covariance projection. Should be quite high, e.g. 5000
    z_steps_trisp: 100  # Type: int. Number of z steps used to compute the trispectrum - around 100 should be enough

    use_KE_approximation: True # Type: bool

    cov_filename: cov_{which_ng_cov:s}_{probe:s}_{ndim}.npz # Type: str. 
    # Name of the output covariance file. Change to '.npy' to save as npy file.

PyCCL:
    cov_integration_method: spline # Type: str
    # (from CCL docs): integration method to be used for the Limber integrals.
    # Possibilities: 'qag_quad' (GSL's qag method backed up by quad when it fails)
    # and 'spline' (the integrand is splined and then integrated analytically).
    # DSnote: note that the former could give errors.

    load_cached_tkka: False # Type: bool # TODO restore if there is time

    n_samples_wf: 1000 # Type: int
    # (from CCL docs): number of points over which to compute the radial kernels (weight functions).
    # See e.g. documentation of https://ccl.readthedocs.io/en/latest/api/pyccl.tracers.html#pyccl.tracers.NumberCountsTracer

    # precision parameters for splines and numerical integration, described in
    # https://ccl.readthedocs.io/en/latest/source/notation_and_other_cosmological_conventions.html#controlling-splines-and-numerical-accuracy.
    spline_params: # Type: dict | None
        A_SPLINE_NA_PK: 240 # Type: int
        K_MAX_SPLINE: 300 # Type: int
    gsl_params: null # Type: dict | None

OneCovariance:
    precision_settings: default # Type: str. Options: ['high_precision', 'default'] # TODO delete this
    path_to_oc_executable: /home/davide/Documenti/Lavoro/Programmi/OneCovariance/covariance.py # Type: str
    path_to_oc_ini: ./input/config_3x2pt_pure_Cell_general.ini # Type: str
    consistency_checks: False # Type: bool

misc:
    num_threads: 40 # Type: int. How many threads to use for the Julia SSC integral with @tturbo

    # some sanity checks on the covariance matrix. These could take a while to run.
    test_numpy_inversion: True # Type: bool. Test for errors in np.linalg.inv
    test_condition_number: True # Type: bool. Check if condition number is above 1e10
    test_cholesky_decomposition: True # Type: bool. Test if cholesky decomposition fails
    test_symmetry: True # Type: bool. Test if covariance matrix is symmetric (cov = cov.T)

    output_path: ./output # Type: str
    save_output_as_benchmark: True # Type: bool. For testing purposes
    bench_filename: ../Spaceborne_bench/output_G{g_code:s}_SSC{ssc_code:s}_cNG{cng_code:s}_KE{use_KE:s}_resp{which_pk_responses:s}_b1g{which_b1g_in_resp:s}_biascheck # Type: str. For testing purposes
