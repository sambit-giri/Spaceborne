# TODO add general description
# TODO merge with cfg.yaml from spaceborne_covg
# TODO add dzGC

cosmology:
    Om: 0.32
    Ob: 0.05
    wz: -1.0
    wa: 0.0
    h: 0.6737
    ns: 0.966
    s8: 0.816
    logT: 7.75
    ODE: 0.68
    m_nu: 0.06
    N_eff: 3.046
    Om_k0: 0

intrinsic_alignment:
    Aia: 0.16
    eIA: 1.66
    bIA: 0.0
    CIA: 0.0134

# extra parameters to be passed to CCL cosmo object, eg CAMB extra parameters
# (see https://ccl.readthedocs.io/en/latest/api/pyccl.cosmology.html#pyccl.cosmology.Cosmology
# for the different options)
extra_parameters:
    camb:
        halofit_version: mead2020_feedback
        kmax: 100
        HMCode_logT_AGN: 7.75
        num_massive_neutrinos: 1
        dark_energy_model: ppf

bias:
    bias_function: analytical # 'analytical', 'leporifit', 'pocinofit'
    bias_model: step-wise # 'step-wise', 'constant', 'linint', 'ones', 'polynomial'
    # coefficients for the polynomial galaxy and magnification bias fits
    galaxy_bias_fit_coeff: [1.33291, -0.72414, 1.0183, -0.14913]
    magnification_bias_fit_coeff: [-1.50685, 1.35034, 0.08321, 0.04279]

    # multiplicative shear bias fiducial parameters
    mult_shear_bias: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

# boolean flags for redshift-space distortion, magnification bias and intrinsic alignment
has_rsd: False
has_magnification_bias: False
has_IA: False

# Halo model configuration using CCL classes (https://ccl.readthedocs.io/en/latest/api/pyccl.halos.html)
# Each parameter maps directly to a CCL class, and has exactly its name
halo_model:
    mass_def: MassDef200m
    concentration: ConcentrationDuffy08
    mass_function: MassFuncTinker10
    halo_bias: HaloBiasTinker10
    halo_profile_dm: HaloProfileNFW
    halo_profile_hod: HaloProfileHOD

# TODO delete which_shape_noise
# TODO delete dz shifts?
# TODO delete nz_folder
# TODO delete nuisance_folder
# TODO delete zbin_centers
# TODO delete ngal_lensing, ngal_clustering
# TODO hardcode shift_nz_interpolation_kind to spline
# TODO remove compute_bnt_with_shifted_nz_for_zcuts??
nz:
    EP_or_ED: EP

    # paths to source and lens redshift distributions. These must have shape (z_points, zbins + 1)
    nz_sources_filename: "/home/davide/Documenti/Lavoro/Programmi/common_data/vincenzo/SPV3_07_2022/LiFEforSPV3_may24/InputFiles/InputNz/NzFid/nzTab-EP03-zedMin02-zedMax25-mag245.dat"
    nz_lenses_filename: "/home/davide/Documenti/Lavoro/Programmi/common_data/vincenzo/SPV3_07_2022/LiFEforSPV3_may24/InputFiles/InputNz/NzFid/nzTab-EP03-zedMin02-zedMax25-mag245.dat"

    # number of galaxies per arcmin**2 for each redshift bin
    ngal_sources: [8.09216, 8.09215, 8.09215]
    ngal_lenses: [8.09216, 8.09215, 8.09215]

    # shift in the redshift distribution per redshift bin
    dzWL: [-0.008848, 0.051368, 0.059484]
    dzGC: [-0.008848, 0.051368, 0.059484]

    shift_nz: True # Vincenzo's kernels are computed using a shifted n(z)!
    shift_nz_interpolation_kind: linear
    normalize_shifted_nz: True
    nz_gaussian_smoothing: False # does not seem to have a large effect...
    nz_gaussian_smoothing_sigma: 2
    plot_nz_tocheck: True

mask:
    nside_mask: 1024
    mask_path: path/to/mask.fits

ell_binning:
    ell_min: 10 # minimum ell for 3x2pt
    ell_max_WL: 3000 # maximum ell for WL
    ell_max_GC: 3000 # maximum ell for GC
    ell_max_3x2pt: 3000
    # the case with the largest range is nbl_WL_opt. This is the reference ell binning from which the cuts are applied;
    # in principle, the other binning should be consistent with this one and should not be hardcoded, as long as
    # lmax=5000, 3000 holds
    nbl_WL_opt: 32 # this is the value from which the various bin cuts are applied, do not change it
    ell_max_WL_opt: 5000 # this is the value from which the various bin cuts are applied, do not change it

# TODO infer zbins from nz
# TODO infer EP Ed from nz
# TODO delete n_probes
# TODO delete which_cls
# TODO delete use_h_units? hardocode to False, maybe?
# TODO delete BNT_transform? as an option here, for sure
# TODO delete which_forecast

ell_cuts:
    apply_ell_cuts: False
    which_cuts: standard
    center_or_min: center # cut if the bin *center* or the bin *lower edge* is larger than ell_max[zi, zj]
    cl_ell_cuts: False
    cov_ell_cuts: False
    kmax_h_over_Mpc_ref: 1.0 # this is used when ell_cuts is False, also...?
    # kmax_list_1_over_Mpc: (0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00, 3.00, 5.00, #10.00)),
    # kmax_h_over_Mpc_list: [0.37108505, 0.74217011, 1.11325516, 1.48434021, 1.85542526,
    #                                   2.22651032, 2.59759537, 2.96868042, 4.45302063, 7.42170105, 14.84340211]
    kmax_h_over_Mpc_list: [0.1, 0.16681005, 0.27825594, 0.46415888, 0.77426368, 1.29154967, 2.15443469, 3.59381366, 5.9948425, 10.]
    use_h_units: False

BNT:
    BNT_transform: False # ! to be deprecated?
    cl_BNT_transform: False
    cov_BNT_transform: False
    compute_bnt_with_shifted_nz_for_zcuts: False # ! lets test this
    include_ia_in_bnt_kernel_for_zcuts: False

covariance:
    n_probes: 2

    G: True
    SSC: True
    cNG: True

    SSC_code: Spaceborne # Spaceborne, OneCovariance or PyCCL
    cNG_code: OneCovariance # OneCovariance or PyCCL

    # ordering-related settings
    triu_tril: triu
    row_col_major: row-major
    block_index: ell
    GL_or_LG: GL
    split_gaussian_cov: False
    covariance_ordering_2D: ell_probe_zpair # TODO restore this

    # fsky: 0.3563380664078408
    # survey_area_deg2: 14700
    fsky: 0.3210678603147902
    survey_area_deg2: 13245

    # ellipticity dispersion *per component* = sigma_eps_i
    # total ellipticity dispersion = sigma_eps
    # sigma_eps = (sigma_eps_i * np.sqrt(2))
    sigma_eps_i: 0.26

    # sigma2_b settings, common to Spaceborne and PyCCL. Can be one of:
    # - full_curved_sky: Use the full- (curved-) sky expression (for Spaceborne only). In this case, the output covmat
    # - from_input_mask: input a mask with path specified by mask_path
    # - polar_cap_on_the_fly: generate a polar cap during the run, with nside specified by nside
    # - null (None): use the flat-sky expression (valid for PyCCL only)
    # - flat_sky: use the flat-sky expression (valud for PyCCL only)
    #   has to be rescaled by fsky
    which_sigma2_b: polar_cap_on_the_fly

    probe: 3x2pt
    which_ng_cov: [SSC] # only SSC available in this case
    which_cNG: null # PyCCL or OneCovariance or null (None)
    load_precomputed_cov: False
    which_pk_responses: halo_model_SB # halo_model_SB, halo_model_CCL (with PyCCL) or separate_universe_SB/_vin (from simulations)
    include_b2g: True # whether or not to include the second-order galaxy bias in the GCph responses
    b2g_from_halomodel: True # TODO DELETE THIS in the main branch
    # Which first-order galaxy bias to use in the computation of the counterterms for the gm and gg responses.
    # Can be one of:
    # - 'from_HOD' (from the Halo Occupation Distribution previously initialized)
    # - 'from_input' (from the input tabulated galaxy bias values)/FS2 fit computed in SB
    # Setting this to 'from_HOD' will match perfectly 'halo_model_CCL'
    which_b1g_in_resp: "from_HOD"

    cov_path: "/home/davide/Documenti/Lavoro/Programmi/common_data/Spaceborne/jobs/SPV3/output/Flagship_{flagship_version:d}/covmat/Spaceborne/{which_pk_responses:s}"
    cov_suffix: "_zsteps{z_steps_ssc_integrands:d}_k{k_txt_label:s}_convention{cl_integral_convention:s}_integration{integration_type:s}_{survey_area_deg2:d}deg2_Francis"

    log10_k_min_sigma2: -4
    log10_k_max_sigma2: 1
    k_steps_sigma2: 20_000 # TODO can I lower this? double bessel integral...
    z_min_ssc_integrands: 0.02 # SU responses' kmax allow for z_min = 0.016, at most.
    z_max_ssc_integrands: 3.
    z_steps_ssc_integrands: 300 # this should be high because I have to trace the spikes in sigma2

    load_precomputed_sigma2: False
    sigma2_b_filename: "/home/davide/Documenti/Lavoro/Programmi/common_data/Spaceborne/jobs/SPV3/output/Flagship_2/sigma2_b/sigma2_b_{ndim:d}D_{which_sigma2_b:s}_zmin{zmin:.1e}_zmax{zmax:.1e}_zsteps{zsteps:d}_log10kmin{log10kmin:.1e}_log10kmax{log10kmax:.1e}_ksteps{ksteps:d}.npy"
    cl_integral_convention: Euclid # "Euclid_KE_approximation" or "PySSC" (results are the same) or "Euclid_KE_approximation"
    use_KE_approximation: False
    integration_type: "simps" # 'simps' or 'simps_KE_approximation' or 'trapz' (which is actually using rectangles)

PyCCL_cfg:
    # cNG or SSC. Which non-Gaussian covariance terms to compute. Must be a tuple
    which_ng_cov: [SSC]

    load_precomputed_cov: False
    save_cov: True
    load_precomputed_tkka: False
    save_hm_responses: True
    save_tkka: True

    cov_path: "/home/davide/Documenti/Lavoro/Programmi/common_data/Spaceborne/jobs/SPV3/output/Flagship_{flagship_version:d}/covmat/PyCCL"
    cov_suffix: ""

    # z_grid min and max should probably coincide. play around with steps to find the minimum number
    z_grid_tkka_min: 0.
    z_grid_tkka_max: 3. # used to be 6
    k_grid_tkka_min: 1.e-5
    k_grid_tkka_max: 1.e+2
    z_grid_tkka_steps_SSC: 100 # (z, k) = (50, 100) seems altrady enough
    k_grid_tkka_steps_SSC: 200
    z_grid_tkka_steps_cNG: 100
    k_grid_tkka_steps_cNG: 512

    n_samples_wf: 1000
    # (from CCL docs): integration method to be used for the Limber integrals.
    # Possibilities: 'qag_quad' (GSL's qag method backed up by quad when it fails) and 'spline' (the integrand is splined and then integrated analytically).
    cov_integration_method: spline

OneCovariance_cfg:
    which_ng_cov: ["SSC"]
    load_precomputed_cov: False
    use_OneCovariance_Gaussian: False
    which_gauss_cov_binning: OneCovariance # 'EC20' or 'OneCovariance'
    precision_settings: high_precision # 'high_precision' or 'default'
    path_to_oc_executable: "/home/davide/Documenti/Lavoro/Programmi/OneCovariance/covariance.py"

    onecovariance_folder: "/home/davide/Documenti/Lavoro/Programmi/common_data/Spaceborne/jobs/SPV3/output/Flagship_2/covmat/OneCovariance/EP03-zedMin02-zedMax25-mag245"
    cov_filename: "cov_{which_ng_cov:s}_onecovariance_{probe_a:s}{probe_b:s}{probe_c:s}{probe_d:s}_4D_nbl{nbl:d}_ellmax{lmax:d}_zbinsEP03_Gbinning{which_gauss_cov_binning:s}.npz"

misc:
    num_threads: 40 # how many threads to use for the Julia SSC integral with @tturbo
    # save_outputs_as_test_benchmarks_path: ./tests/benchmarks/output_dict.npy
    save_outputs_as_test_benchmarks_path: False

    output_folder: '../output'
    use_h_units: False  # TODO hardcode!
